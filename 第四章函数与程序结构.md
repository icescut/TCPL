# 函数与程序结构
函数的定义与使用。几个特殊的变量：外部变量、静态变量、寄存器变量。作用域与头文件。预处理器。  
C语言一般由许多小的函数组成，而不是由少量较大的函数组成。  

## 函数
函数的定义形式：
```C
返回值类型 函数名(参数声明表)
{
    声明和语句
}
```
函数定义的各构成部分都可以省略，最简单的形式`dummy(){}`，如果没有返回值，默认为int。  
程序可以看成是变量定义和函数定义的集合。函数声明可以与变量定义写在一起，如`double sum, atof(char [])`。  
函数的声明与定义必须一致，否则会报错或运行时出现奇怪的错误。如果没有函数原型，执行不会出错，将被隐式声明，但默认返回值为int。  
函数可以直接或间接调用自身，称之为*递归*，递归的执行速度并不快，但递归代码比较紧凑。  

## 外部变量
定义在函数之外，可以被所有函数使用，定义只有一次，声明可以有多次，声明一般写在头文件中。通过同一个名字对外部变量的所有引用，实际上都是引用的同一个对象。  
当外部变量的定义与使用不在同一个文件，必须使用extern强制声明。一个外部变量只能在某个文件定义一次，而其他文件可以通过extern声明来访问它。外部变量的初始化只能出现在其定义中。  
C语言不允许在一个函数中定义其他函数，因为函数本身就是“外部的”。  
外部变量的特点：
1. 比使用一个很长的参数表更方便、有效（无需建立副本）。
2. 可能对程序结构产生不良影响，导致各个函数之间有太多的数据联系
3. 相比内部变量具有更大的作用域和更长的生存期

```C
在文件file1中:
    extern int sp;
    void push(double f){...}
在文件file2中:
    int sp = 0;
```

## 作用域与程序块
构成C语言程序的函数和外部变量可以分开进行编译。  
名字的作用域是指程序中可以使用该名字的部分：  
- 自动变量，其作用域是声明该变量名的函数。不同函数中的相同名字的自动变量没有关系，参数与是如此。
- 外部变量或函数，从声明（注意和定义的不同）它的地方开始，到其所在文件（注意不是所有文件）的末尾。

变量的声明除了可以紧跟在函数开始的花括号之后，还可以紧跟在任何其他标识复合语句开始的左花括号之后。以这种方式都的变量可以隐藏程序块之外与之同名的变量。应该发行量避免出现变量名隐藏外部作用域中相同名字的情况。
```C
if(n > 0) {
    int i;
    for (i = 0; i < n; ++i)
        ...
}
```

## 头文件
可以把公共部分放在头文件。  

## 静态变量
通常情况下，函数名字是全局可访问的，对整个程序的各个部分而言都可见。  
1. 修饰外部变量和函数，将作用域限定为当前文件的剩余部分，其他文件无法访问。  
2. 修饰内部变量，一直存在，不像自动变量那样，随着函数调用退出而消失。

## 寄存器变量
register声明告诉编译器，它声明的变量使用频率较高，应该放在寄存器中，但编译器可以选择忽略。过量的寄存器变量没有什么害处。  

## 初始化
在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为0,而自动变量和寄存器变量的初始则没有定义。  
对于外部变量和静态变量来说，初始化表达式必须是常量表达式。对于自动变量和寄存器变量，初始化表达式可以不是常量表达式。  
数组与结构的初始化可以紧跟一个*初始化表达式列表*。初始化表达式列表用花括号括起来，通过逗号分隔：`int days[] = {1, 2, 3}`。当省略数组长度时，将花括号中元素的个数作为数组的长度。如果初始化表达式列表的个数比数组元素少，则默认初始化为0，如果多，则是错误的。  
字符初始化比较特殊，可以用一个字符串代替初始化表达式列表。比如`char s[] = "hello"`，等价于`char s[] = {'h', 'e', 'l', 'l', 'o', '\0'}`

## 预处理器
预处理是编译过程中单独执行的第一个步骤。最常用的指令为#define和#include。#include指令用于在编译期间把指定文件的内容包含进当前文件中，用于保证所有的源文件都有相同的定义和变量声明。#define指令用任意字符序列替代一个标记。  
```C
#include <文件名>  //根据相应的规则查找该文件
#include "文件名"  //在源文件所在的位置查找该文件
```

### 宏替换
```C
#define 名字 替换文本
```
后续所有出现名字记号的地方都将被替换为替换文本。如果宏定义较长，可以在待续的行尾加上一个反斜杠\\。作用域从定义的地方开始都被编译的源文件的末尾。可以使用前面出现的宏定义，只对记号替换，对括在引号中的字符串不起作用。宏参数与可以带参数：
```C
#define max(A, B) ((A) > (B) ? (A) : (B)) //这里括号的使用有必要
```
使用宏可能会产生一些副作用，还必须使用圆括号保证计算顺序的正确。但是宏可以避免函数建立退出时产生的开销。  
通过#undef指令取消名字的宏定义。  
参数名以#作用前缀则将实际参数替换为带引用的字符串：
```C
#define dprint(expr) printf(#expr " = %g\n", expr)
...
dprint(x/y)  //扩展为dprint("x/y" " = %g\n", expr)
```
预处理器运算符##用于连接实际参数：
```C
#define paste(front, back) front ## back
...
paste(name, 1) //扩展为name1
```

### 条件包含
在预处理过程中进行条件选择执行。#if语句对其中的常量整型表达式（不包括sizeof、类型转换、enum）进行求值。如果值不为0，则执行其后各行，直到遇到#endif、#elif或#else。#if可以使用表达式`defined(名字)`，如果已定义则值为1，否则为0。  
避免头文件重复包含：
```C
#if !defined(HDR)
#define HDR
#endif
//但通常使用下面这种方式
#ifndef HKD
#define HDR
#endif
```
