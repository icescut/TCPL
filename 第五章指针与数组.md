# 指针与数组
指针是一种保存变量地址的变量。指针常常是表达某个计算的惟一途径，并且指针通常可以生成更高效、更紧凑的代码。使用void \*作为通用的指针类型，能与其他指针类型互相转换。  

## 指针与地址
指针是能够存放一个地址的一组存储单元（通常是4个字节）。  
一元运算符&可以用于取一个对象的地址。`p = &c;`，将把c的地址赋值给变量p，称之为p指向c。  
一元运算符\*是间接寻址或间接引用运算符，作用于指针，将返回指针所指向的对象。  
指针的声明：
```C
int *p; //说明表达式*p的返回值是int类型的。
```
指针只能指向某种特定类型的对象，void类型指针除外。注意\*与++这类运算符结合的优先级和结合顺序（可参考《C缺陷与陷阱》）。指针也是变量，可以直接使用，例如，`iq = ip;`。  
指针参数使得被调用函数可以访问和修改调用函数的变量。  
## 指针与数组
指针与数组的关系十分密切，所有数组下标操作都可以用指针代替。相对而言，指针更高效，但不易理解。  
数组名基本等同于指向数组的指针，有一点不同是，数组名不是变量，不能改变。假设一数组a，指针p指向数组a。那么，a等价&a[0];a[i]等价\*(a+i)等价\*(p+i)等价p[i];&a[i]等价a+i等价p+i等价&p[i]。实际上，数组下标背后应该就是用指针实现的。  
可以将子数组的起始位置传递给函数，函数不关心是完整的数组还是部分数组。如果确信元素存在，可以用a[-1]/a[-2]等访问第一个元素之前的位置。  
## 地址算术运算
地址算术运算与数组是紧密结合的。会根据指针的类型自动计算正确的位置。有效的运算:
- 同类型指针的赋值（void指针是特例）  
- 指针与整型的加减法。
- 指向同一数组中元素的指针的减法和比较。  
- 将指针赋值0，指针与0的比较。  

## 字符指针与函数
字符串常量实际上是一个字符数组，该字符数组以'\0'结束，所以数组传递是字符数量加一。  

## 指针数组及指向指针的指针
指针本身也是变量，可以作为数组元素。指针数组的定义:
```C
类型 *数组名[大小]
```
字符指针数组可通过字符串列表初始化:
```C
char *a[] = {"Peter", "John", "May"};
```

## 多维数组
多维数组并没有指针数组用得那么广泛。定义:
```C
类型 数组名[行][列]
```
当二维数组作为参数，行数可省略，列数不可省，否则无法划分行。
二维数组每行已分配固定空间，但指针数组没个元素只是一个指针。   

## 命令行参数
main函数有两个参数:argc为命令行参数的个数，argv为命令行参数的字符指针数组。根据约定argv[0]为执行程序的名字，所以argc至少为1。  

## 函数指针
函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值，存放在数组中，传递给函数，作为函数返回值。定义:`类型 （*指针名）（）`,指针名外部的圆括号不能省，否则为返回指针的函数。例如:
```C
int (*p)(); //指向返回值为int的指针
int *f(); //返回值为指针的函数
```
任何类型的指针都可以转换为void*，并且将它转换回原类型时不会损失信息。  

## 复杂声明
声明可以定义为`类型 声明符`。声明符可以分解为:
```C
dcl: 前面带可选个数*的direct-dcl
direct-dcl: name
            (dcl)
            direct-dcl()
            direct-dcl[可选的长度]
```

经典分析:
```C
//（）与[]的结合性比*高。从名字开始，由内而外分析，类似于表达式
char *x(); //函数返回char类型指针
char (*x)(); //指向函数的指针
char *x[]; //char指针数组
char (*x)[]; //指向char数组的指针
char (*(*x())[])();
//A.x()，根据优先级， x只能是一个函数的名字，x()是函数的返回值
//B.*x()，*A，那么A只能是一个指针，表示x函数返回值为指针
//C.(*x())[]，B[],表示B的指向一个数组，数组名类似于指针。
//D.*(*x())[]，*B[]，B指向的数组为指针数组，因为只有指针才能用*操作
//E.(*(*x())[])()，D()，D指针的指向为函数地址，只有这样才能调用函数
```
原则:由内而外求值，判断这是什么才能完成求值。指针指向的位置可能是数组开始位置或函数开始位置  
